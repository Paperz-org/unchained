{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Unchained Framework","text":"<p>A modern, type-safe Python web framework built on top of Django with dependency injection.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install unchained\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<pre><code># app.py\nfrom unchained import Unchained\nfrom django.db import models\nfrom unchained.models.base import BaseModel\n\n# Define your application\napp = Unchained()\n\n# Define a model\nclass Task(BaseModel):\n    title = models.CharField(max_length=100)\n    description = models.TextField(null=True, blank=True)\n    completed = models.BooleanField(default=False)\n\n    def __str__(self):\n        return self.title\n\n# Generate CRUD endpoints for Task model\napp.crud(Task)\n\n# Custom endpoint\n@app.get(\"/hello/{name}\")\ndef hello(name: str):\n    return {\"message\": f\"Hello {name}!\"}\n\n# Dependency injection example\n@app.get(\"/tasks/completed\")\ndef completed_tasks():\n    return Task.objects.filter(completed=True).all()\n\n# Run your application with:\n# uvicorn app:app\n</code></pre> <p>To get started:</p> <ol> <li>Install Unchained: <code>pip install unchained</code></li> <li>Create app.py with the code above</li> <li>Set up the database: <code>unchained migrate</code></li> <li>Run the server: <code>uvicorn app:app</code></li> <li>Visit http://127.0.0.1:8000/docs to view your API documentation</li> </ol> <p>See our detailed quickstart guide for a full example \u2192</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Django Integration - Leverage Django's powerful ORM and admin</li> <li>FastAPI-like Routing - Modern, intuitive API endpoints</li> <li>CRUD Generator - Automatic endpoints for your models</li> <li>Type Safety - Full static type checking</li> <li>Dependency Injection - Clean, modular code architecture</li> <li>Admin Interface - Customizable admin dashboard</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Routing</li> <li>Models &amp; CRUD</li> <li>Dependency Injection</li> <li>State Management</li> <li>Admin Interface</li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>Check out the quickstart guide for complete examples of:</p> <ul> <li>Basic API setup</li> <li>CRUD applications</li> <li>Dependency injection implementation</li> </ul>"},{"location":"#need-help","title":"Need Help?","text":"<p>GitHub Issues</p>"},{"location":"contributing/","title":"Contributing to Unchained","text":"<p>Community Driven</p> <p>We welcome contributions to Unchained! This guide will help you get started with contributing to the project.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"Step 1: Clone the repositoryStep 2: Create a virtual environmentStep 3: Install dependencies <pre><code>git clone git@github.com:yourusername/unchained.git\ncd unchained\n</code></pre> <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n</code></pre> <pre><code>pip install -e \".[dev]\"\n</code></pre> <p>Virtual Environment</p> <p>Always use a virtual environment to avoid conflicts with other projects or system-wide Python packages.</p>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<p>Use pytest to verify that your changes don't break existing functionality:</p> <pre><code>pytest\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>Unchained uses <code>ruff</code> for code formatting and linting:</p> Command Description <code>ruff format src tests</code> Format code according to project style <code>ruff check src tests</code> Check code for style and error issues"},{"location":"contributing/#contribution-workflow","title":"Contribution Workflow","text":"<p> Step 1: Create a new branch <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> <p> Step 2: Make your changes <pre><code># Write your code and tests\n</code></pre></p> <p> Step 3: Commit your changes <pre><code>git add .\ngit commit -m \"Add your feature or fix description\"\n</code></pre></p> <p> Step 4: Push your changes <pre><code>git push origin feature/your-feature-name\n</code></pre></p> <p> Step 5: Create a pull request on GitHub</p> <p>Good Pull Requests</p> <ul> <li>Have a clear purpose and description</li> <li>Include tests for new functionality</li> <li>Update documentation as needed</li> <li>Follow the code style guidelines</li> <li>Address one concern or feature at a time</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>When making documentation changes:</p> <ol> <li>Edit markdown files in the <code>docs/</code> directory</li> <li>Run the documentation server to preview changes:    <pre><code>mkdocs serve\n</code></pre></li> <li>Visit http://127.0.0.1:8001 in your browser</li> </ol>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<p>If you have questions or need help:</p> <ul> <li> Open an issue on GitHub</li> <li> Check existing issues and discussions</li> </ul>"},{"location":"quickstart/","title":"Quickstart Guide","text":"<p>This guide will help you create a fully functional application with Unchained in minutes.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<pre><code>pip install unchained\n</code></pre>"},{"location":"quickstart/#complete-example","title":"Complete Example","text":"<p>Below is a single-file application that demonstrates the key features of Unchained:</p> <pre><code># app.py\nfrom unchained import Unchained, Depends\nfrom django.db import models\nfrom unchained.models.base import BaseModel\nfrom typing import List, Optional\n\n# Create your application\napp = Unchained()\n\n# Define models\nclass Category(BaseModel):\n    name = models.CharField(max_length=100, unique=True)\n\n    def __str__(self):\n        return self.name\n\nclass Task(BaseModel):\n    title = models.CharField(max_length=100)\n    description = models.TextField(null=True, blank=True)\n    completed = models.BooleanField(default=False)\n    due_date = models.DateField(null=True)\n    category = models.ForeignKey(Category, on_delete=models.CASCADE, related_name=\"tasks\", null=True)\n\n    def __str__(self):\n        return self.title\n\n# Generate CRUD endpoints for both models\napp.crud(Category)\napp.crud(Task)\n\n# Define a dependency\ndef get_task_by_id(task_id: int):\n    try:\n        return Task.objects.get(id=task_id)\n    except Task.DoesNotExist:\n        return {\"error\": \"Task not found\"}\n\n# Basic route\n@app.get(\"/\")\ndef home():\n    return {\"message\": \"Welcome to the Task Manager API\"}\n\n# Path parameter example\n@app.get(\"/hello/{name}\")\ndef hello(name: str):\n    return {\"message\": f\"Hello {name}!\"}\n\n# Query parameter example\n@app.get(\"/tasks/filter\")\ndef filter_tasks(completed: Optional[bool] = None, category: Optional[str] = None):\n    query = Task.objects.all()\n\n    if completed is not None:\n        query = query.filter(completed=completed)\n\n    if category:\n        query = query.filter(category__name=category)\n\n    return list(query.values())\n\n# Dependency injection example\n@app.get(\"/tasks/{task_id}/details\")\ndef task_details(task = Depends(get_task_by_id)):\n    return task\n\n# POST request with body\n@app.post(\"/tasks/create\")\ndef create_task(task_data: dict):\n    category = None\n    if task_data.get(\"category_id\"):\n        try:\n            category = Category.objects.get(id=task_data[\"category_id\"])\n        except Category.DoesNotExist:\n            pass\n\n    task = Task(\n        title=task_data[\"title\"],\n        description=task_data.get(\"description\", \"\"),\n        completed=task_data.get(\"completed\", False),\n        due_date=task_data.get(\"due_date\"),\n        category=category\n    )\n    task.save()\n    return task\n\n# Application state (middleware)\n@app.before_request\ndef log_request():\n    print(\"Request received\")\n\n@app.after_request\ndef log_response():\n    print(\"Response sent\")\n</code></pre>"},{"location":"quickstart/#running-your-application","title":"Running Your Application","text":"<ol> <li>Save the code above as <code>app.py</code></li> <li>Run database migrations:    <pre><code>unchained migrations create\nunchained migrations apply\n</code></pre></li> <li>Start the server:    <pre><code>unchained start app:app\n</code></pre></li> <li>Open your browser to <code>http://127.0.0.1:8000/docs</code> to see the interactive API documentation</li> </ol>"},{"location":"quickstart/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<ul> <li>Models - Django models with relationships</li> <li>CRUD Operations - Automatic API endpoints</li> <li>Routing - Path and query parameters</li> <li>Dependency Injection - Clean separation of concerns</li> <li>Request Handling - Working with request body</li> <li>Middleware - Request/response hooks</li> <li>API Documentation - Automatic OpenAPI docs</li> </ul>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about authentication and security features</li> <li>Explore advanced models in the documentation</li> <li>Set up custom admin pages </li> </ul>"},{"location":"cli/commands/","title":"Unchained CLI Commands","text":"<p>The Unchained framework provides a command-line interface for various tasks like running development servers, managing database migrations, creating superusers, and more.</p>"},{"location":"cli/commands/#command-structure","title":"Command Structure","text":"<p>All commands use the <code>unchained</code> prefix and follow this pattern:</p> <pre><code>unchained [command] [subcommand] [options]\n</code></pre> <p>Many commands accept an <code>app_path</code> argument which specifies the location of your application in the format <code>module:instance</code>. If not provided, the CLI will attempt to automatically detect your app from:</p> <ol> <li><code>UNCHAINED_APP_PATH</code> environment variable</li> <li><code>pyproject.toml</code> file with <code>[tool.unchained]</code> section</li> <li>Common app patterns in the current directory</li> </ol>"},{"location":"cli/commands/#main-commands","title":"Main Commands","text":""},{"location":"cli/commands/#unchained-start","title":"<code>unchained start</code>","text":"<p>Run the development server using uvicorn.</p> <pre><code>unchained start [app_path] [options]\n</code></pre> <p>Options: - <code>--host</code>, <code>-h</code>: Host to bind the server to (default: 127.0.0.1) - <code>--port</code>, <code>-p</code>: Port to bind the server to (default: 8000) - <code>--reload/--no-reload</code>: Enable/disable auto-reload for development (default: enabled)</p> <p>Example: <pre><code>unchained start\nunchained start --port 8080\nunchained start myapp:app --host 0.0.0.0 --no-reload\n</code></pre></p>"},{"location":"cli/commands/#unchained-collectstatic","title":"<code>unchained collectstatic</code>","text":"<p>Collect static files for production deployment.</p> <pre><code>unchained collectstatic\n</code></pre>"},{"location":"cli/commands/#unchained-version","title":"<code>unchained version</code>","text":"<p>Show the current version of Unchained.</p> <pre><code>unchained version\n</code></pre>"},{"location":"cli/commands/#unchained-createsuperuser","title":"<code>unchained createsuperuser</code>","text":"<p>Create a superuser account for the admin interface.</p> <pre><code>unchained createsuperuser [app_path] [username] [email] [noinput]\n</code></pre> <p>Examples: <pre><code>unchained createsuperuser\n</code></pre></p>"},{"location":"cli/commands/#unchained-shell","title":"<code>unchained shell</code>","text":"<p>Start the Django shell with your application context loaded.</p> <pre><code>unchained shell [app_path]\n</code></pre>"},{"location":"cli/commands/#database-migration-commands","title":"Database Migration Commands","text":"<p>Unchained provides a set of commands for managing database migrations under the <code>migrations</code> namespace.</p>"},{"location":"cli/commands/#unchained-migrations-create","title":"<code>unchained migrations create</code>","text":"<p>Create new database migrations based on model changes.</p> <pre><code>unchained migrations create \n</code></pre>"},{"location":"cli/commands/#unchained-migrations-apply","title":"<code>unchained migrations apply</code>","text":"<p>Apply migrations to sync the database with your models.</p> <pre><code>unchained migrations apply [app_path] [app_label] [migration_name]\n</code></pre> <p>Arguments: - <code>app_label</code>: App label to migrate (optional, migrates all apps if not specified) - <code>migration_name</code>: Specific migration to apply (optional, requires app_label)</p> <p>Examples: <pre><code>unchained migrations apply                   # Apply all pending migrations\nunchained migrations apply myapp             # Apply migrations for 'myapp' only\nunchained migrations apply myapp 0002        # Apply specific migration\n</code></pre></p>"},{"location":"cli/commands/#unchained-migrations-show","title":"<code>unchained migrations show</code>","text":"<p>Show the status of all database migrations.</p> <pre><code>unchained migrations show [app_path] [app_label]\n</code></pre> <p>Arguments: - <code>app_label</code>: App label to show migrations for (optional, shows all apps if not specified)</p> <p>Examples: <pre><code>unchained migrations show\nunchained migrations show myapp\n</code></pre></p>"},{"location":"core/admin/","title":"Admin Interface","text":"<p>Django Admin Integration</p> <p>Unchained provides seamless integration with Django's admin interface, allowing you to manage your models through a web interface.</p>"},{"location":"core/admin/#basic-usage","title":"Basic Usage","text":"Register a ModelInline Admin <pre><code>from django.contrib import admin\nfrom unchained import Unchained\n\nclass UserAdmin(admin.ModelAdmin):\n    list_display = ['name', 'email', 'is_active']\n    search_fields = ['name', 'email']\n\napp = Unchained()\napp.admin.register(User, UserAdmin)\n</code></pre> <pre><code>class PostInline(admin.TabularInline):\n    model = Post\n    extra = 1\n\nclass UserAdmin(admin.ModelAdmin):\n    inlines = [PostInline]\n</code></pre>"},{"location":"core/admin/#admin-customization","title":"Admin Customization","text":"List DisplayCustom Actions <pre><code>class UserAdmin(admin.ModelAdmin):\n    list_display = ['name', 'email', 'is_active', 'created_at']\n    list_filter = ['is_active', 'created_at']\n    search_fields = ['name', 'email']\n    ordering = ['-created_at']\n</code></pre> <pre><code>class UserAdmin(admin.ModelAdmin):\n    actions = ['activate_users', 'deactivate_users']\n\n    @admin.action(description='Activate selected users')\n    def activate_users(self, request, queryset):\n        queryset.update(is_active=True)\n\n    @admin.action(description='Deactivate selected users')\n    def deactivate_users(self, request, queryset):\n        queryset.update(is_active=False)\n</code></pre>"},{"location":"core/admin/#advanced-features","title":"Advanced Features","text":"Custom FieldsCustom Templates <pre><code>class UserAdmin(admin.ModelAdmin):\n    readonly_fields = ['created_at', 'updated_at']\n    fieldsets = [\n        (None, {'fields': ['name', 'email']}),\n        ('Status', {'fields': ['is_active']}),\n        ('Dates', {'fields': ['created_at', 'updated_at']})\n    ]\n</code></pre> <pre><code>class UserAdmin(admin.ModelAdmin):\n    change_list_template = 'admin/user_change_list.html'\n    change_form_template = 'admin/user_change_form.html'\n</code></pre>"},{"location":"core/admin/#best-practices","title":"Best Practices","text":"<ol> <li>Security: Always implement proper permissions</li> <li>Performance: Use list_select_related for foreign keys</li> <li>Usability: Add helpful filters and search fields</li> <li>Maintenance: Keep admin classes simple and focused</li> </ol>"},{"location":"core/admin/#common-patterns","title":"Common Patterns","text":""},{"location":"core/admin/#model-mixins","title":"Model Mixins","text":"<pre><code>class TimestampAdmin(admin.ModelAdmin):\n    readonly_fields = ['created_at', 'updated_at']\n    list_display = ['created_at', 'updated_at']\n\nclass UserAdmin(TimestampAdmin):\n    list_display = ['name', 'email', 'is_active'] + TimestampAdmin.list_display\n</code></pre>"},{"location":"core/admin/#custom-filters","title":"Custom Filters","text":"<pre><code>from django.contrib.admin import SimpleListFilter\n\nclass ActiveFilter(SimpleListFilter):\n    title = 'Active Status'\n    parameter_name = 'is_active'\n\n    def lookups(self, request, model_admin):\n        return [\n            ('yes', 'Active'),\n            ('no', 'Inactive')\n        ]\n\n    def queryset(self, request, queryset):\n        if self.value() == 'yes':\n            return queryset.filter(is_active=True)\n        if self.value() == 'no':\n            return queryset.filter(is_active=False)\n\nclass UserAdmin(admin.ModelAdmin):\n    list_filter = [ActiveFilter]\n</code></pre>"},{"location":"core/admin/#custom-views","title":"Custom Views","text":"<pre><code>from django.urls import path\nfrom django.shortcuts import render\n\nclass UserAdmin(admin.ModelAdmin):\n    def get_urls(self):\n        urls = super().get_urls()\n        custom_urls = [\n            path('custom-view/', self.admin_site.admin_view(self.custom_view))\n        ]\n        return custom_urls + urls\n\n    def custom_view(self, request):\n        return render(request, 'admin/custom_view.html')\n</code></pre>"},{"location":"core/admin/#example-complete-admin-setup","title":"Example: Complete Admin Setup","text":"<pre><code>from django.contrib import admin\nfrom django.contrib.admin import SimpleListFilter\nfrom django.urls import path\nfrom django.shortcuts import render\n\nclass ActiveFilter(SimpleListFilter):\n    title = 'Active Status'\n    parameter_name = 'is_active'\n\n    def lookups(self, request, model_admin):\n        return [\n            ('yes', 'Active'),\n            ('no', 'Inactive')\n        ]\n\n    def queryset(self, request, queryset):\n        if self.value() == 'yes':\n            return queryset.filter(is_active=True)\n        if self.value() == 'no':\n            return queryset.filter(is_active=False)\n\nclass UserAdmin(admin.ModelAdmin):\n    list_display = ['name', 'email', 'is_active', 'created_at']\n    list_filter = [ActiveFilter, 'created_at']\n    search_fields = ['name', 'email']\n    readonly_fields = ['created_at', 'updated_at']\n    ordering = ['-created_at']\n\n    fieldsets = [\n        (None, {'fields': ['name', 'email']}),\n        ('Status', {'fields': ['is_active']}),\n        ('Dates', {'fields': ['created_at', 'updated_at']})\n    ]\n\n    actions = ['activate_users', 'deactivate_users']\n\n    @admin.action(description='Activate selected users')\n    def activate_users(self, request, queryset):\n        queryset.update(is_active=True)\n\n    @admin.action(description='Deactivate selected users')\n    def deactivate_users(self, request, queryset):\n        queryset.update(is_active=False)\n\n    def get_urls(self):\n        urls = super().get_urls()\n        custom_urls = [\n            path('custom-view/', self.admin_site.admin_view(self.custom_view))\n        ]\n        return custom_urls + urls\n\n    def custom_view(self, request):\n        return render(request, 'admin/custom_view.html')\n\napp = Unchained()\napp.admin.register(User, UserAdmin)\n</code></pre>"},{"location":"core/crud/","title":"CRUD Operations","text":"<p>Automatic CRUD Generation</p> <p>Unchained provides automatic CRUD endpoint generation for your Django models with minimal setup.</p>"},{"location":"core/crud/#basic-crud","title":"Basic CRUD","text":"Simple SetupCustomized CRUDPartial CRUD <pre><code>app.crud(User)  # Generates all CRUD endpoints\n</code></pre> <pre><code>app.crud(\n    User,\n    operations=\"CRUD\",  # Create, Read, Update, Delete\n    path=\"/users\",      # Custom path\n    tags=[\"Users\"]      # API tags\n)\n</code></pre> <pre><code>app.crud(\n    User,\n    operations=\"CR\",    # Only Create and Read\n    path=\"/users\"\n)\n</code></pre>"},{"location":"core/crud/#operations-parameter","title":"Operations Parameter","text":"<p>The <code>operations</code> parameter allows you to control which CRUD operations are generated for your model. Each letter in the string represents a specific operation:</p> <ul> <li>C: Create - POST endpoint to create new records</li> <li>R: Read - GET endpoints to retrieve individual records and lists of records</li> <li>U: Update - PUT/PATCH endpoints to modify existing records</li> <li>D: Delete - DELETE endpoint to remove records</li> </ul>"},{"location":"core/crud/#examples","title":"Examples","text":"<pre><code># Full CRUD (default if not specified)\napp.crud(User, operations=\"CRUD\")\n\n# Read-only API\napp.crud(User, operations=\"R\")\n\n# Create and Read only (no updates or deletes)\napp.crud(User, operations=\"CR\")\n\n# Create, Read, and Update (no delete capability)\napp.crud(User, operations=\"CRU\")\n</code></pre>"},{"location":"core/crud/#generated-endpoints","title":"Generated Endpoints","text":"<p>For a model with <code>operations=\"CRUD\"</code> and <code>path=\"/users\"</code>, the following endpoints would be generated:</p> Method Endpoint Operation Description POST /users/ Create Create a new user GET /users/ Read List all users (with pagination) GET /users/{id} Read Get a specific user by ID PUT /users/{id} Update Update a specific user (full update) PATCH /users/{id} Update Update a specific user (partial update) DELETE /users/{id} Delete Delete a specific user <p>You can combine any subset of \"CRUD\" to generate only the endpoints you need for your application.</p>"},{"location":"core/crud/#custom-schemas","title":"Custom Schemas","text":"<p>Customize the input and output data models for your CRUD operations using Pydantic schemas.</p> Input SchemaOutput Schema <pre><code>from pydantic import BaseModel\n\nclass UserCreate(BaseModel):\n    name: str\n    email: str\n    password: str\n\napp.crud(\n    User,\n    create_schema=UserCreate\n)\n</code></pre> <pre><code>class UserRead(BaseModel):\n    id: int\n    name: str\n    email: str\n    is_active: bool\n\napp.crud(\n    User,\n    read_schema=UserRead\n)\n</code></pre>"},{"location":"core/crud/#filtering-and-pagination","title":"Filtering and Pagination","text":"<p>Control which records are returned and how they're organized.</p> Filter SchemaCustom QuerySet <pre><code>class UserFilter(BaseModel):\n    name: str | None = None\n    email: str | None = None\n    is_active: bool | None = None\n\napp.crud(\n    User,\n    filter_schema=UserFilter\n)\n</code></pre> <pre><code>app.crud(\n    User,\n    queryset=User.objects.filter(is_active=True)\n)\n</code></pre>"},{"location":"core/crud/#best-practices","title":"Best Practices","text":"<ol> <li>Type Safety: Always use type hints in schemas for better documentation and validation</li> <li>Validation: Use Pydantic models for input validation with appropriate field constraints</li> <li>Consistency: Follow a consistent naming scheme for your schemas and endpoints</li> </ol>"},{"location":"core/crud/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"core/crud/#response-models","title":"Response Models","text":"<p>Control what fields are returned in responses:</p> <pre><code>app.crud(\n    User,\n    read_schema=UserRead,\n    list_schema=UserList  # Different schema for list endpoint\n)\n</code></pre>"},{"location":"core/crud/#authentication-and-permissions","title":"Authentication and Permissions","text":"<p>Add authentication and permission requirements:</p> <pre><code>from unchained.auth import jwt_required\n\napp.crud(\n    User,\n    auth=[jwt_required],\n    permissions=[\"admin\"]\n)\n</code></pre>"},{"location":"core/crud/#custom-endpoints","title":"Custom Endpoints","text":"<p>Add additional custom endpoints alongside standard CRUD:</p> <pre><code>user_crud = app.crud(User)\n\n@user_crud.router.get(\"/me\")\ndef get_current_user():\n    # Custom endpoint logic\n    pass\n</code></pre>"},{"location":"core/crud/#complete-example","title":"Complete Example","text":"<pre><code>from django.db import models\nfrom pydantic import BaseModel, EmailStr, Field\nfrom unchained.models.base import BaseModel as UnchainedModel\n\n# Schemas\nclass UserCreate(BaseModel):\n    name: str\n    email: EmailStr\n    password: str = Field(..., min_length=8)\n\nclass UserRead(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n    is_active: bool\n\nclass UserFilter(BaseModel):\n    name: str | None = None\n    email: str | None = None\n    is_active: bool | None = None\n\n# Model\nclass User(UnchainedModel):\n    name = models.CharField(max_length=255)\n    email = models.EmailField(unique=True)\n    password = models.CharField(max_length=255)\n    is_active = models.BooleanField(default=True)\n\n    class Meta:\n        ordering = [\"-id\"]\n\n# CRUD Setup\napp.crud(\n    User,\n    create_schema=UserCreate,\n    read_schema=UserRead,\n    filter_schema=UserFilter,\n    operations=\"CRUD\",\n    path=\"/users\",\n    tags=[\"Users\"]\n)\n</code></pre> <p>For information about model definition and database migrations, see the Models documentation. </p>"},{"location":"core/dependency-injection/","title":"Dependency Injection","text":"<p>Power of Dependency Injection</p> <p>Unchained provides a robust dependency injection system built on FastDepends, enabling clean, testable, and modular code with full type safety.</p>"},{"location":"core/dependency-injection/#what-is-dependency-injection","title":"What is Dependency Injection?","text":"<p>Dependency injection is a design pattern that allows you to:</p> <ul> <li>Separate the creation of dependencies from their usage</li> <li>Improve testability by making dependencies replaceable</li> <li>Create reusable components that can be shared across your application</li> <li>Keep your code modular and maintainable</li> </ul> <p>In Unchained, dependency injection is implemented using Python's <code>Annotated</code> type and the <code>Depends</code> function.</p>"},{"location":"core/dependency-injection/#basic-usage","title":"Basic Usage","text":"<p>Important: Using <code>Annotated</code></p> <p>Unchained's dependency injection system requires the use of Python's <code>Annotated</code> type. Direct parameter typing without <code>Annotated</code> will not work for dependencies.</p> Simple DependencyParameterized Dependency <pre><code>from typing import Annotated\nfrom unchained import Depends, Unchained\n\napp = Unchained()\n\ndef get_current_user():\n    return {\"username\": \"johndoe\"}\n\n@app.get(\"/me\")\ndef read_current_user(user: Annotated[dict, Depends(get_current_user)]):\n    return user\n</code></pre> <pre><code>from typing import Annotated\nfrom unchained import Depends, Unchained\n\napp = Unchained()\n\ndef get_item_by_id(item_id: int):\n    return {\"item_id\": item_id, \"name\": f\"Item {item_id}\"}\n\n@app.get(\"/items/{item_id}\")\ndef read_item(item: Annotated[dict, Depends(get_item_by_id)]):\n    return item\n</code></pre>"},{"location":"core/dependency-injection/#automatic-dependencies","title":"Automatic Dependencies","text":"<p>Unchained provides several built-in dependencies that are automatically injected when you type-annotate your parameters:</p> Request ObjectApplication ObjectState ObjectSettings Object <pre><code>from unchained import Request, Unchained\n\napp = Unchained()\n\n@app.get(\"/request-info\")\ndef get_request_info(request: Request):\n    return {\n        \"method\": request.method,\n        \"url\": str(request.url),\n        \"headers\": dict(request.headers)\n    }\n</code></pre> <pre><code>from unchained import Unchained\nfrom unchained.base import BaseUnchained\n\napp = Unchained()\n\n@app.get(\"/app-info\")\ndef get_app_info(app: BaseUnchained):\n    return {\n        \"debug\": app.debug,\n        \"version\": app.version\n    }\n</code></pre> <pre><code>from unchained import Unchained\nfrom unchained.states import BaseState\n# Or your custom state\nfrom myapp.state import AppState\n\napp = Unchained()\n\n@app.get(\"/state-info\")\ndef get_state_info(state: BaseState):  # Or state: AppState\n    return {\n        \"debug\": state.debug,\n        \"environment\": state.environment\n    }\n</code></pre> <pre><code>from unchained import Unchained\nfrom unchained.settings.base import UnchainedSettings\n# Or your custom settings\nfrom myapp.settings import AppSettings\n\napp = Unchained()\n\n@app.get(\"/settings-info\")\ndef get_settings_info(settings: UnchainedSettings):  # Or settings: AppSettings\n    return {\n        \"debug\": settings.debug,\n        \"database_url\": settings.database_url\n    }\n</code></pre> <p>For more information about state management, see the state management documentation.</p>"},{"location":"core/dependency-injection/#type-aliases-for-dependencies","title":"Type Aliases for Dependencies","text":"<p>You can create clear and reusable type aliases for your dependencies, which improves code organization and readability:</p> <pre><code>from typing import Annotated\nfrom unchained import Depends, Unchained\nfrom httpx import AsyncClient\n\napp = Unchained()\n\ndef get_api_client() -&gt; AsyncClient:\n    return AsyncClient(base_url=\"https://api.example.com\")\n\n# Create a type alias for the dependency\nApiClient = Annotated[AsyncClient, Depends(get_api_client)]\n\n@app.get(\"/external-data\")\ndef get_external_data(client: ApiClient):\n    # Use the client with full IDE completion\n    response = client.get(\"/data\")\n    return response.json()\n</code></pre> <p>This pattern is particularly useful for:</p> <ul> <li>Improving code readability</li> <li>Enabling better IDE support</li> <li>Reusing dependencies across multiple endpoints</li> <li>Making the dependency relationship clear</li> </ul>"},{"location":"core/dependency-injection/#nested-dependencies","title":"Nested Dependencies","text":"<p>Dependencies can depend on other dependencies, creating a dependency graph:</p> <pre><code>from typing import Annotated\nfrom unchained import Depends, Unchained\n\napp = Unchained()\n\ndef get_api_key():\n    return \"api-key-1234\"\n\ndef get_headers(api_key: Annotated[str, Depends(get_api_key)]):\n    return {\"Authorization\": f\"Bearer {api_key}\"}\n\ndef get_client(headers: Annotated[dict, Depends(get_headers)]):\n    # In a real app, you might return httpx.AsyncClient or similar\n    return {\"headers\": headers, \"client\": \"api_client\"}\n\n@app.get(\"/api-data\")\ndef get_data(client: Annotated[dict, Depends(get_client)]):\n    # Access the fully resolved dependency chain\n    return {\"data\": \"some data\", \"client\": client}\n</code></pre> <p>When a request is made to <code>/api-data</code>:</p> <ol> <li><code>get_api_key()</code> is called first</li> <li>Its return value is passed to <code>get_headers()</code></li> <li>The result from <code>get_headers()</code> is passed to <code>get_client()</code></li> <li>Finally, the <code>get_client()</code> result is injected as the <code>client</code> parameter</li> </ol>"},{"location":"core/dependency-injection/#advanced-examples-with-custom-state-and-settings","title":"Advanced Examples with Custom State and Settings","text":"<p>Here are simpler examples showing how to leverage custom state and settings:</p>"},{"location":"core/dependency-injection/#custom-state-example","title":"Custom State Example","text":"<pre><code>from typing import Annotated, Optional\nfrom unchained import Depends, Unchained\nfrom unchained.states import BaseState\nfrom httpx import AsyncClient\n\n# Define custom state\nclass AppState(BaseState):\n    weather_api_key: str = \"default-key\"\n    logger_enabled: bool = True\n\n# Get configuration from state\ndef get_api_config(state: AppState):\n    return {\n        \"api_key\": state.weather_api_key,\n        \"logging\": state.logger_enabled\n    }\n\n# Use the configuration\ndef get_weather_info(config: Annotated[dict, Depends(get_api_config)]):\n    # Simple function returning weather info based on config\n    return {\n        \"source\": \"Weather API\",\n        \"using_key\": config[\"api_key\"],\n        \"logging_enabled\": config[\"logging\"]\n    }\n\n# Create app with state\napp = Unchained(state=AppState())\n\n# Use in endpoint\n@app.get(\"/weather-config\")\ndef weather_config(info: Annotated[dict, Depends(get_weather_info)]):\n    return info\n</code></pre>"},{"location":"core/dependency-injection/#custom-settings-example","title":"Custom Settings Example","text":"<pre><code>from typing import Annotated\nfrom unchained import Depends, Unchained\nfrom unchained.settings.base import UnchainedSettings\nfrom pydantic import Field\n\n# Define custom settings\nclass AppSettings(UnchainedSettings):\n    # API Settings\n    api_timeout: int = Field(default=30, ge=1, le=120)\n    enable_cache: bool = Field(default=True)\n\n# Simple feature flag checker\ndef is_feature_enabled(feature_name: str, settings: AppSettings):\n    if feature_name == \"cache\":\n        return settings.enable_cache\n    return False\n\n# Get timeout configuration\ndef get_timeout_config(settings: AppSettings):\n    return {\n        \"timeout\": settings.api_timeout,\n        \"cache_enabled\": settings.enable_cache\n    }\n\n# Create app\napp = Unchained()\n\n# Use settings in endpoint\n@app.get(\"/api-config\")\ndef api_config(\n    config: Annotated[dict, Depends(get_timeout_config)],\n    cache_enabled: Annotated[bool, Depends(lambda s: is_feature_enabled(\"cache\", s))]\n):\n    return {\n        \"config\": config,\n        \"cache_status\": \"enabled\" if cache_enabled else \"disabled\"\n    }\n</code></pre>"},{"location":"core/dependency-injection/#combining-custom-state-and-settings","title":"Combining Custom State and Settings","text":"<pre><code>from typing import Annotated\nfrom unchained import Depends, Unchained\nfrom unchained.states import BaseState\nfrom unchained.settings.base import UnchainedSettings\nfrom pydantic import Field\n\n# Custom settings\nclass ApiSettings(UnchainedSettings):\n    base_url: str = Field(default=\"https://api.example.com\")\n    timeout: int = Field(default=30)\n\n# Custom state\nclass AppState(BaseState):\n    api_key: str = \"default-key\"\n    debug_mode: bool = False\n\n# Initialize app\napp = Unchained(state=AppState())\n\n# Function that uses both state and settings\ndef get_api_configuration(state: AppState, settings: ApiSettings):\n    return {\n        \"base_url\": settings.base_url,\n        \"timeout\": settings.timeout,\n        \"api_key\": state.api_key,\n        \"debug\": state.debug_mode\n    }\n\n# Use the configuration\n@app.get(\"/api-status\")\ndef api_status(config: Annotated[dict, Depends(get_api_configuration)]):\n    return {\n        \"status\": \"configured\",\n        \"config\": config\n    }\n</code></pre>"},{"location":"core/dependency-injection/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use <code>Annotated</code> for All Dependencies: Always use <code>Annotated</code> with <code>Depends</code> for proper type inference.</p> </li> <li> <p>Keep Dependencies Focused: Each dependency should have a single responsibility.</p> </li> <li> <p>Prefer Function Dependencies: Function-based dependencies are easier to test and mock.</p> </li> <li> <p>Cache When Appropriate: Use <code>use_cache=True</code> (the default) to avoid recalculating the same dependency.</p> </li> <li> <p>Handle Errors Properly: Dependencies should raise appropriate exceptions for error scenarios.</p> </li> </ol>"},{"location":"core/dependency-injection/#implementation-details","title":"Implementation Details","text":"<p>Under the hood, Unchained uses FastDepends to handle dependency resolution. The process works as follows:</p> <ol> <li>When a route is registered, Unchained analyzes its signature</li> <li>For each parameter with <code>Annotated[Type, Depends(...)]</code>, it registers the dependency</li> <li>Automatic dependencies like <code>Request</code>, <code>BaseUnchained</code>, <code>BaseState</code>, and <code>UnchainedSettings</code> are detected by type</li> <li>When a request arrives, dependencies are resolved in the correct order</li> <li>The resolved values are passed to the route handler</li> </ol>"},{"location":"core/lifespan/","title":"Lifespan Management","text":"<p>Application Lifecycle</p> <p>Unchained provides a powerful lifespan management system that allows you to handle application startup and shutdown events.</p>"},{"location":"core/lifespan/#what-is-lifespan","title":"What is Lifespan?","text":"<p>Lifespan is a concept from the ASGI (Asynchronous Server Gateway Interface) specification that manages the lifecycle of an application. The lifespan protocol provides hooks for:</p> <ul> <li>Startup: Actions to perform when the server starts, before handling any requests</li> <li>Shutdown: Cleanup actions to perform when the server is shutting down</li> </ul> <p>Unchained builds upon this ASGI concept to provide a clean, intuitive API for managing application lifecycle events.</p> <p>Lifespan Functions Must Yield</p> <p>All lifespan functions must use the <code>yield</code> statement to separate startup from shutdown logic. Failing to yield will result in an error.</p>"},{"location":"core/lifespan/#ways-to-define-lifespan","title":"Ways to Define Lifespan","text":"<p>There are two ways to define lifespan handlers in Unchained:</p>"},{"location":"core/lifespan/#1-using-the-decorator","title":"1. Using the Decorator","text":"<pre><code>from unchained import Unchained\n\napp = Unchained()\n\n@app.lifespan\ndef startup(app: Unchained):\n    # Startup code (executed before the server starts handling requests)\n    print(\"Server is starting up\")\n    app.state.initialized = True\n\n    yield  # This yield separates startup from shutdown code\n\n    # Shutdown code (executed when the server is shutting down)\n    print(\"Server is shutting down\")\n    app.state.initialized = False\n</code></pre>"},{"location":"core/lifespan/#2-during-initialization","title":"2. During Initialization","text":"<pre><code>from unchained import Unchained\n\nasync def my_lifespan(app: Unchained):\n    # Startup code\n    print(\"Starting up\")\n    yield\n    # Shutdown code\n    print(\"Shutting down\")\n\n# Pass the lifespan function during app initialization\napp = Unchained(lifespan=my_lifespan)\n</code></pre>"},{"location":"core/lifespan/#sync-vs-async-lifespan","title":"Sync vs Async Lifespan","text":"<p>Unchained supports both synchronous and asynchronous lifespan handlers:</p> Sync LifespanAsync Lifespan <pre><code>@app.lifespan\ndef startup(app: Unchained):\n    # Synchronous startup code\n    app.state.initialized = True\n    yield\n    # Synchronous shutdown code\n    app.state.initialized = False\n</code></pre> <pre><code>@app.lifespan\nasync def startup(app: Unchained):\n    # Asynchronous startup code\n    await app.state.http_client.aopen()\n    yield\n    # Asynchronous shutdown code\n    await app.state.http_client.aclose()\n</code></pre>"},{"location":"core/lifespan/#how-lifespan-works-in-asgi","title":"How Lifespan Works in ASGI","text":"<p>When an ASGI server (like Uvicorn or Daphne) starts, it sends a lifespan event to the application:</p> <ol> <li>Server sends <code>{\"type\": \"lifespan.startup\"}</code> to the application</li> <li>Application executes all startup code (before the <code>yield</code>)</li> <li>Application responds with <code>{\"type\": \"lifespan.startup.complete\"}</code></li> <li>Server starts handling HTTP requests</li> <li>When shutting down, server sends <code>{\"type\": \"lifespan.shutdown\"}</code></li> <li>Application executes all shutdown code (after the <code>yield</code>)</li> <li>Application responds with <code>{\"type\": \"lifespan.shutdown.complete\"}</code></li> </ol> <p>Unchained handles all of this communication for you, providing a clean API that focuses on your application logic rather than the ASGI protocol details.</p>"},{"location":"core/lifespan/#multiple-lifespan-handlers","title":"Multiple Lifespan Handlers","text":"<p>You can define multiple lifespan handlers, and they will be executed in the order they are defined:</p> <pre><code>@app.lifespan\nasync def http_client_lifespan(app: Unchained):\n    app.state.http_client = httpx.AsyncClient()\n    yield\n    await app.state.http_client.aclose()\n\n@app.lifespan\nasync def cache_lifespan(app: Unchained):\n    await app.state.cache.connect()\n    yield\n    await app.state.cache.disconnect()\n</code></pre> <p>On startup, the handlers execute in order (http_client_lifespan then cache_lifespan).  On shutdown, they execute in reverse order (cache_lifespan cleanup then http_client_lifespan cleanup).</p>"},{"location":"core/lifespan/#common-use-cases","title":"Common Use Cases","text":""},{"location":"core/lifespan/#resource-initialization-and-cleanup","title":"Resource Initialization and Cleanup","text":"<p>The most common use case for lifespan is initializing resources at startup and cleaning them up at shutdown:</p> <pre><code>@app.lifespan\nasync def initialize_resources(app: Unchained):\n    # Initialize resources\n    app.state.http_client = AsyncClient()\n    app.state.redis = Redis.from_url(os.getenv(\"REDIS_URL\"))\n\n    # Return control to the server\n    yield\n\n    # Clean up resources\n    await app.state.http_client.aclose()\n    await app.state.redis.close()\n</code></pre>"},{"location":"core/lifespan/#error-handling","title":"Error Handling","text":"<p>When working with lifespan functions, it's important to handle potential errors properly:</p> Startup Error HandlingShutdown Error Handling <pre><code>@app.lifespan\nasync def startup(app: Unchained):\n    # Initialize client\n    app.state.http_client = httpx.AsyncClient()\n\n    # Yield control back to the server\n    yield\n\n    # Always clean up resources\n    await app.state.http_client.aclose()\n</code></pre> <pre><code>@app.lifespan\nasync def shutdown(app: Unchained):\n    # Initialize client\n    app.state.http_client = httpx.AsyncClient()\n\n    # Yield control back to the server\n    yield\n\n    # Clean up (errors here will be logged but won't crash the application)\n    await app.state.http_client.aclose()\n</code></pre>"},{"location":"core/lifespan/#best-practices","title":"Best Practices","text":"<ol> <li>Always Yield: Every lifespan function must yield exactly once</li> <li>Resource Management: Always clean up resources during shutdown</li> <li>Error Handling: Use try/except/finally for robust error handling</li> <li>State Initialization: Use lifespan for initializing application state</li> <li>Ordering: Be conscious of the order of lifespan handlers</li> </ol>"},{"location":"core/lifespan/#example-complete-application-setup","title":"Example: Complete Application Setup","text":"<pre><code>from unchained import Unchained\nfrom unchained.states import BaseState\nimport httpx\nimport redis\nimport os\n\nclass AppState(BaseState):\n    debug: bool = False\n    api_key: str\n    environment: str = \"development\"\n\napp = Unchained(state=AppState())\n\n@app.lifespan\ndef load_config(app: Unchained):\n    # Load configuration\n    app.state.debug = os.getenv(\"DEBUG\", \"false\").lower() == \"true\"\n    app.state.api_key = os.getenv(\"API_KEY\")\n    app.state.environment = os.getenv(\"ENVIRONMENT\", \"development\")\n    yield\n    # No cleanup needed\n\n@app.lifespan\nasync def initialize_clients(app: Unchained):\n    # Initialize clients\n    app.state.http_client = httpx.AsyncClient(\n        headers={\"Authorization\": f\"Bearer {app.state.api_key}\"}\n    )\n    app.state.redis = redis.Redis.from_url(os.getenv(\"REDIS_URL\"))\n\n    yield\n\n    # Clean up\n    await app.state.http_client.aclose()\n    await app.state.redis.close()\n</code></pre>"},{"location":"core/models/","title":"Models &amp; Migrations","text":"<p>Django Models</p> <p>Unchained provides seamless integration with Django's ORM for model definition and database management.</p>"},{"location":"core/models/#basic-models","title":"Basic Models","text":"Define a ModelModel Relationships <pre><code>from django.db import models\nfrom unchained.models.base import BaseModel\n\nclass User(BaseModel):\n    name = models.CharField(max_length=255)\n    email = models.EmailField(unique=True)\n    is_active = models.BooleanField(default=True)\n</code></pre> <pre><code>class Post(BaseModel):\n    title = models.CharField(max_length=255)\n    content = models.TextField()\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    tags = models.ManyToManyField(Tag)\n</code></pre>"},{"location":"core/models/#common-model-patterns","title":"Common Model Patterns","text":""},{"location":"core/models/#soft-delete","title":"Soft Delete","text":"<pre><code>class SoftDeleteModel(BaseModel):\n    is_deleted = models.BooleanField(default=False)\n\n    class Meta:\n        abstract = True\n\n    def delete(self, *args, **kwargs):\n        self.is_deleted = True\n        self.save()\n\nclass User(SoftDeleteModel):\n    name = models.CharField(max_length=255)\n</code></pre>"},{"location":"core/models/#timestamps","title":"Timestamps","text":"<pre><code>class TimestampModel(BaseModel):\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        abstract = True\n\nclass Post(TimestampModel):\n    title = models.CharField(max_length=255)\n</code></pre>"},{"location":"core/models/#custom-manager","title":"Custom Manager","text":"<pre><code>class ActiveUserManager(models.Manager):\n    def get_queryset(self):\n        return super().get_queryset().filter(is_active=True)\n\nclass User(BaseModel):\n    name = models.CharField(max_length=255)\n    is_active = models.BooleanField(default=True)\n\n    objects = models.Manager()\n    active = ActiveUserManager()\n</code></pre>"},{"location":"core/models/#database-migrations","title":"Database Migrations","text":"<p>Unchained uses Django's migration system to manage database schema changes. After defining or modifying your models, you'll need to create and apply migrations.</p>"},{"location":"core/models/#creating-migrations","title":"Creating Migrations","text":"<p>To create new migrations based on model changes:</p> <pre><code>unchained migrations create [name]\n</code></pre> <p>Where <code>[name]</code> is an optional name for the migration (e.g., \"add_user_model\").</p>"},{"location":"core/models/#applying-migrations","title":"Applying Migrations","text":"<p>To apply migrations and update your database schema:</p> <pre><code>unchained migrations apply\n</code></pre>"},{"location":"core/models/#viewing-migration-status","title":"Viewing Migration Status","text":"<p>To see which migrations have been applied:</p> <pre><code>unchained migrations show\n</code></pre> <p>For detailed information about migration commands and options, see the CLI documentation.</p>"},{"location":"core/models/#best-practices","title":"Best Practices","text":"<ol> <li>Use abstract models for common fields and behavior</li> <li>Add Meta options for ordering, indexes, and constraints</li> <li>Create migrations early to catch model issues</li> <li>Keep migrations small to make deployments safer</li> <li>Test migrations on a copy of production data when possible</li> </ol> <p>For information about generating CRUD endpoints from your models, see the CRUD documentation. </p>"},{"location":"core/routing/","title":"Routing","text":"<p>URL Routing</p> <p>Unchained provides a powerful routing system that allows you to define API endpoints with type safety and dependency injection.</p>"},{"location":"core/routing/#basic-routing","title":"Basic Routing","text":"Simple Route <pre><code>@app.get(\"/hello\")\ndef hello():\n    return {\"message\": \"Hello, World!\"}\n</code></pre>"},{"location":"core/routing/#http-methods","title":"HTTP Methods","text":"GETPOSTPUTDELETE <pre><code>@app.get(\"/items\")\ndef get_items():\n    return {\"items\": []}\n</code></pre> <pre><code>@app.post(\"/items\")\ndef create_item(item: Item):\n    return {\"item\": item}\n</code></pre> <pre><code>@app.put(\"/items/{item_id}\")\ndef update_item(item_id: int, item: Item):\n    return {\"item_id\": item_id, \"item\": item}\n</code></pre> <pre><code>@app.delete(\"/items/{item_id}\")\ndef delete_item(item_id: int):\n    return {\"deleted\": item_id}\n</code></pre>"},{"location":"core/routing/#request-body","title":"Request Body","text":"<p>Unchained leverages Pydantic for powerful, automatic request body validation. Simply define your data structure as a Pydantic model and use it as a parameter in your route function.</p> Basic Request BodyNested ModelsField ValidationError Handling <pre><code>from pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    description: str = None\n    tags: list[str] = []\n\n@app.post(\"/items\")\ndef create_item(item: Item):\n    # The item parameter will automatically be populated from the request JSON body\n    # Validation happens automatically based on the Pydantic model\n    return {\"item_id\": 123, \"item\": item}\n</code></pre> <pre><code>from pydantic import BaseModel\n\nclass Image(BaseModel):\n    url: str\n    width: int\n    height: int\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    images: list[Image] = []\n\n@app.post(\"/items\")\ndef create_item(item: Item):\n    # Nested objects are validated recursively\n    return {\"item\": item}\n</code></pre> <pre><code>from pydantic import BaseModel, Field, EmailStr\n\nclass User(BaseModel):\n    username: str = Field(..., min_length=3, max_length=50)\n    email: EmailStr\n    age: int = Field(..., ge=18, description=\"Age must be at least 18\")\n\n@app.post(\"/users\")\ndef create_user(user: User):\n    # Validation will ensure:\n    # - username is between 3-50 characters\n    # - email is a valid email format\n    # - age is at least 18\n    return {\"user_id\": 123, \"user\": user}\n</code></pre> <p>When validation fails, Unchained automatically returns a 422 Unprocessable Entity response with details about the validation errors:</p> <pre><code>{\n  \"detail\": [\n    {\n      \"loc\": [\"body\", \"username\"],\n      \"msg\": \"ensure this value has at least 3 characters\",\n      \"type\": \"value_error.any_str.min_length\"\n    },\n    {\n      \"loc\": [\"body\", \"age\"],\n      \"msg\": \"ensure this value is greater than or equal to 18\",\n      \"type\": \"value_error.number.not_ge\"\n    }\n  ]\n}\n</code></pre>"},{"location":"core/routing/#request-and-response","title":"Request and Response","text":"Request ObjectResponse Object <pre><code>from unchained import Request\n\n@app.get(\"/request\")\ndef get_request(request: Request):\n    return {\n        \"method\": request.method,\n        \"headers\": dict(request.headers),\n        \"query_params\": dict(request.query_params)\n    }\n</code></pre> <pre><code>from unchained import Response\n\n@app.get(\"/custom-response\")\ndef custom_response():\n    return Response(\n        content={\"message\": \"Custom response\"},\n        status_code=201,\n        headers={\"X-Custom\": \"value\"}\n    )\n</code></pre>"},{"location":"core/routing/#modular-routing","title":"Modular Routing","text":"Router DefinitionRouter Registration <pre><code>from unchained.routers import Router\n\nrouter = Router()\n\n@router.get(\"/items\")\ndef get_items():\n    return {\"items\": []}\n</code></pre> <pre><code>app.add_router(\"/api\", router)\n# Routes will be available at /api/items\n</code></pre>"},{"location":"core/routing/#path-parameters","title":"Path Parameters","text":"Basic TypesCustom Types <pre><code>@app.get(\"/items/{item_id}\")\ndef get_item(item_id: int):\n    return {\"item_id\": item_id}\n</code></pre> <pre><code>from pydantic import BaseModel\n\nclass ItemID(BaseModel):\n    id: int\n\n    @classmethod\n    def __get_validators__(cls):\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, v):\n        if not isinstance(v, int):\n            raise ValueError(\"Item ID must be an integer\")\n        if v &lt; 1:\n            raise ValueError(\"Item ID must be positive\")\n        return cls(id=v)\n\n@app.get(\"/items/{item_id}\")\ndef get_item(item_id: ItemID):\n    return {\"item_id\": item_id.id}\n</code></pre>"},{"location":"core/routing/#headers","title":"Headers","text":"<pre><code>from typing import Annotated\nfrom unchained.dependencies.header import Header\n\n@app.get(\"/items\")\ndef get_items(user_agent: Annotated[str, Header()]):\n    return {\"user_agent\": user_agent}\n</code></pre>"},{"location":"core/routing/#query-parameters","title":"Query Parameters","text":"<p>Access query parameters directly from the request object:</p> <pre><code>@app.get(\"/items\")\ndef get_items(request: Request):\n    page = int(request.query_params.get(\"page\", 1))\n    limit = int(request.query_params.get(\"limit\", 10))\n\n    return {\n        \"items\": [],\n        \"page\": page,\n        \"limit\": limit\n    }\n</code></pre>"},{"location":"core/routing/#best-practices","title":"Best Practices","text":"<ol> <li>Type Safety: Always use type hints for parameters</li> <li>Validation: Use Pydantic models for request/response validation</li> <li>Modularity: Split routes into logical routers</li> <li>Documentation: Add docstrings to describe endpoint behavior</li> </ol>"},{"location":"core/routing/#common-patterns","title":"Common Patterns","text":""},{"location":"core/routing/#versioning","title":"Versioning","text":"<pre><code>from unchained.routers import Router\n\nv1 = Router()\nv2 = Router()\n\n@v1.get(\"/items\")\ndef get_items_v1():\n    return {\"version\": \"v1\", \"items\": []}\n\n@v2.get(\"/items\")\ndef get_items_v2():\n    return {\"version\": \"v2\", \"items\": []}\n\napp.add_router(\"/api/v1\", v1)\napp.add_router(\"/api/v2\", v2)\n</code></pre>"},{"location":"core/settings/","title":"Settings Management","text":"<p>Configuration Management</p> <p>Unchained provides a flexible settings management system that allows you to configure your application using Python classes.</p>"},{"location":"core/settings/#basic-usage","title":"Basic Usage","text":"Define SettingsUse SettingsAccess Settings <pre><code>from unchained.settings import UnchainedSettings\n\nclass Settings(UnchainedSettings):\n    DEBUG: bool = False\n    DATABASE_URL: str\n    API_KEY: str | None = None\n</code></pre> <pre><code>from unchained import Unchained\n\napp = Unchained(settings=Settings())\n</code></pre> <pre><code>@app.get(\"/config\")\ndef get_config(settings: Settings):\n    return {\n        \"debug\": settings.DEBUG,\n        \"has_api_key\": bool(settings.API_KEY)\n    }\n</code></pre>"},{"location":"core/settings/#environment-variables","title":"Environment Variables","text":"Load from EnvironmentCustom Environment Names <pre><code>class Settings(UnchainedSettings):\n    DEBUG: bool = False\n    DATABASE_URL: str\n    API_KEY: str | None = None\n\n    class Config:\n        env_prefix = \"APP_\"  # APP_DEBUG, APP_DATABASE_URL, etc.\n</code></pre> <pre><code>class Settings(UnchainedSettings):\n    DEBUG: bool = False\n    DATABASE_URL: str\n    API_KEY: str | None = None\n\n    class Config:\n        env_prefix = \"APP_\"\n        env_nested_delimiter = \"__\"\n        # APP_DATABASE__URL, APP_DATABASE__PORT\n</code></pre>"},{"location":"core/settings/#type-safety","title":"Type Safety","text":"Type ValidationCustom Types <pre><code>class Settings(UnchainedSettings):\n    PORT: int = 8000\n    TIMEOUT: float = 30.0\n    ALLOWED_HOSTS: list[str] = [\"localhost\"]\n    DATABASE: dict[str, str] = {\n        \"url\": \"postgres://localhost\",\n        \"port\": \"5432\"\n    }\n</code></pre> <pre><code>from typing import Literal\nfrom pydantic import HttpUrl\n\nclass Settings(UnchainedSettings):\n    ENVIRONMENT: Literal[\"development\", \"production\"] = \"development\"\n    API_URL: HttpUrl\n    LOG_LEVEL: Literal[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\"] = \"INFO\"\n</code></pre>"},{"location":"core/settings/#best-practices","title":"Best Practices","text":"<ol> <li>Type Safety: Always use type hints for settings</li> <li>Default Values: Provide sensible defaults for optional settings</li> <li>Environment Variables: Use environment variables for sensitive data</li> <li>Validation: Use Pydantic's validation features</li> </ol>"},{"location":"core/settings/#common-patterns","title":"Common Patterns","text":""},{"location":"core/settings/#database-configuration","title":"Database Configuration","text":"<pre><code>class DatabaseSettings(UnchainedSettings):\n    URL: str\n    PORT: int = 5432\n    USER: str\n    PASSWORD: str\n    NAME: str\n\n    class Config:\n        env_prefix = \"DB_\"\n</code></pre>"},{"location":"core/settings/#api-configuration","title":"API Configuration","text":"<pre><code>class APISettings(UnchainedSettings):\n    HOST: str = \"0.0.0.0\"\n    PORT: int = 8000\n    DEBUG: bool = False\n    SECRET_KEY: str\n    ALLOWED_HOSTS: list[str] = [\"*\"]\n\n    class Config:\n        env_prefix = \"API_\"\n</code></pre>"},{"location":"core/settings/#feature-flags","title":"Feature Flags","text":"<pre><code>class FeatureSettings(UnchainedSettings):\n    ENABLE_NEW_UI: bool = False\n    ENABLE_EXPERIMENTAL: bool = False\n    MAX_CONNECTIONS: int = 100\n    CACHE_TIMEOUT: int = 300\n\n    class Config:\n        env_prefix = \"FEATURE_\"\n</code></pre>"},{"location":"core/settings/#nested-settings","title":"Nested Settings","text":"<pre><code>class DatabaseSettings(UnchainedSettings):\n    URL: str\n    PORT: int = 5432\n\nclass CacheSettings(UnchainedSettings):\n    URL: str\n    TIMEOUT: int = 300\n\nclass Settings(UnchainedSettings):\n    DEBUG: bool = False\n    DATABASE: DatabaseSettings\n    CACHE: CacheSettings\n\n    class Config:\n        env_prefix = \"APP_\"\n        env_nested_delimiter = \"__\"\n        # APP_DATABASE__URL, APP_CACHE__TIMEOUT\n</code></pre>"},{"location":"core/settings/#validation","title":"Validation","text":"<pre><code>from pydantic import validator\n\nclass Settings(UnchainedSettings):\n    PORT: int = 8000\n    HOST: str = \"0.0.0.0\"\n\n    @validator(\"PORT\")\n    def validate_port(cls, v):\n        if v &lt; 1024:\n            raise ValueError(\"Port must be greater than 1024\")\n        return v\n\n    @validator(\"HOST\")\n    def validate_host(cls, v):\n        if v not in [\"0.0.0.0\", \"127.0.0.1\", \"localhost\"]:\n            raise ValueError(\"Invalid host\")\n        return v\n</code></pre>"},{"location":"core/state/","title":"State Management","text":"<p>Application State</p> <p>Unchained provides a powerful state management system that allows you to maintain application-wide variables and configurations, with full IDE completion support.</p> <p>State and Lifespan</p> <p>State management is closely tied to lifespan management. The lifespan provides the ideal place to initialize state values at application startup and clean up resources at shutdown.</p> <p>Custom State Classes</p> <p>Custom BaseState classes are currently used primarily for typing purposes. They define the structure and type information for your application state, but the actual initialization happens in lifespan functions, not within the state class itself.</p>"},{"location":"core/state/#basic-usage","title":"Basic Usage","text":"Define StateInitialize with State <pre><code>from unchained.states import BaseState\nfrom typing import Optional\nfrom redis import Redis\nfrom httpx import AsyncClient\n\n# State class is a type placeholder that defines structure\nclass AppState(BaseState):\n    # Cache\n    redis: Redis\n    # API Clients\n    http_client: Optional[AsyncClient] = None\n    weather_client: Optional[AsyncClient] = None\n    # Feature Flags\n    enable_new_ui: bool = False\n    enable_experimental_features: bool = False\n    # Configuration\n    api_key: str\n    debug: bool = False\n</code></pre> <pre><code>from unchained import Unchained\nfrom redis import Redis\nfrom httpx import AsyncClient\n\n# Create app with state placeholder\napp = Unchained(state=AppState())\n\n# Actual initialization happens in lifespan\n@app.lifespan\nasync def startup(app: Unchained):\n    # Initialize Redis\n    app.state.redis = Redis.from_url(\"redis://localhost:6379\")\n\n    # Initialize API clients\n    app.state.http_client = AsyncClient()\n    app.state.weather_client = AsyncClient(\n        base_url=\"https://api.openweathermap.org/data/2.5\",\n        params={\"appid\": app.state.api_key}\n    )\n\n    yield\n\n    # Cleanup\n    await app.state.redis.close()\n    await app.state.http_client.aclose()\n    await app.state.weather_client.aclose()\n</code></pre>"},{"location":"core/state/#state-access","title":"State Access","text":"Direct AccessState with Dependency Injection <pre><code># Access state properties directly from app\ndebug_mode = app.state.debug\n\n# Conditionally use features\nif app.state.enable_experimental_features:\n    # Do something with experimental features\n    pass\n</code></pre> <pre><code>from unchained import Depends\n\n# State can be accessed through dependency injection\ndef get_http_client(app = Depends()):\n    return app.state.http_client\n\n# Note: For detailed examples of using state with dependency injection,\n# see the Dependency Injection documentation\n</code></pre>"},{"location":"core/state/#state-setup-example","title":"State Setup Example","text":"<pre><code>from typing import Optional\nfrom unchained.states import BaseState\nfrom redis import Redis\nfrom httpx import AsyncClient\nimport os\n\n# Define state structure with typing\nclass AppState(BaseState):\n    # Cache\n    redis: Redis\n    # API Clients\n    http_client: Optional[AsyncClient] = None\n    weather_client: Optional[AsyncClient] = None\n    open_ai_client: Optional[AsyncClient] = None\n    # Feature Flags\n    enable_new_ui: bool = False\n    enable_experimental_features: bool = False\n    # Configuration\n    api_key: str\n    debug: bool = False\n    # Environment\n    environment: str = \"development\"\n\napp = Unchained(state=AppState())\n\n# Actual state initialization in lifespan\n@app.lifespan\nasync def startup(app: Unchained):\n    # Load configuration from environment\n    app.state.api_key = os.getenv(\"WEATHER_API_KEY\")\n    app.state.environment = os.getenv(\"ENVIRONMENT\", \"development\")\n    app.state.debug = app.state.environment == \"development\"\n\n    # Initialize services\n    app.state.redis = Redis.from_url(os.getenv(\"REDIS_URL\"))\n\n    # Initialize API clients\n    app.state.http_client = AsyncClient(\n        timeout=30.0,\n        limits=httpx.Limits(max_connections=100)\n    )\n    app.state.weather_client = AsyncClient(\n        base_url=\"https://api.openweathermap.org/data/2.5\",\n        params={\"appid\": app.state.api_key}\n    )\n    app.state.open_ai_client = AsyncClient(\n        base_url=\"https://api.openai.com/v1\",\n        headers={\"Authorization\": f\"Bearer {os.getenv('OPENAI_API_KEY')}\"}\n    )\n\n    # Set feature flags based on environment\n    app.state.enable_new_ui = app.state.environment == \"production\"\n    app.state.enable_experimental_features = app.state.debug\n\n    yield\n\n    # Cleanup\n    await app.state.redis.close()\n    await app.state.http_client.aclose()\n    await app.state.weather_client.aclose()\n    await app.state.open_ai_client.aclose()\n</code></pre>"},{"location":"core/state/#best-practices","title":"Best Practices","text":"<ol> <li>Type Safety: Define state classes with proper type hints</li> <li>IDE Completion: Use state classes for better IDE support</li> <li>Lifespan Initialization: Initialize state in lifespan functions, not state classes</li> <li>Environment Awareness: Use state for environment-specific configuration</li> </ol>"},{"location":"core/state/#common-patterns","title":"Common Patterns","text":""},{"location":"core/state/#service-clients","title":"Service Clients","text":"<pre><code>from unchained.states import BaseState\nfrom typing import Optional\nfrom httpx import AsyncClient\n\n# Type definition for service clients\nclass ServiceClients(BaseState):\n    http: Optional[AsyncClient] = None\n    weather: Optional[AsyncClient] = None\n    github: Optional[AsyncClient] = None\n</code></pre>"},{"location":"core/state/#feature-flags","title":"Feature Flags","text":"<pre><code>from unchained.states import BaseState\n\n# Type definition for feature flags\nclass FeatureFlags(BaseState):\n    enable_new_ui: bool = False\n    enable_experimental_features: bool = False\n    max_connections: int = 100\n    cache_timeout: int = 300\n</code></pre>"},{"location":"core/state/#configuration","title":"Configuration","text":"<pre><code>from unchained.states import BaseState\n\n# Type definition for app configuration\nclass AppConfig(BaseState):\n    api_key: str\n    environment: str = \"development\"\n    debug: bool = False\n    redis_url: str\n    cache_ttl: int = 300\n</code></pre>"},{"location":"crud/customizing/","title":"CRUD Operations","text":"<p>Rapid Development</p> <p>Unchained provides automatic CRUD (Create, Read, Update, Delete) operations through the <code>app.crud()</code> method, enabling you to build REST APIs with minimal code.</p>"},{"location":"crud/customizing/#basic-usage","title":"Basic Usage","text":"<p>With just a single line of code, you can generate complete CRUD endpoints for your models:</p> <pre><code>from unchained import Unchained\nfrom unchained.models.base import BaseModel\nfrom django.db import models\n\nclass User(BaseModel):\n    name = models.CharField(max_length=255)\n    email = models.EmailField(unique=True)\n\napp = Unchained()\napp.crud(User)  # Generates all CRUD endpoints for User model\n</code></pre> <p>Generated Endpoints</p> <p>The <code>app.crud(User)</code> method generates the following endpoints:</p> <ul> <li><code>GET /api/users</code> - List all users</li> <li><code>GET /api/users/{id}</code> - Get a specific user by ID</li> <li><code>POST /api/users</code> - Create a new user</li> <li><code>PUT /api/users/{id}</code> - Update a user</li> <li><code>DELETE /api/users/{id}</code> - Delete a user</li> </ul>"},{"location":"crud/customizing/#example-usage","title":"Example Usage","text":"Model DefinitionAPI SetupAPI Usage <pre><code>from django.db import models\nfrom unchained.models.base import BaseModel\n\nclass Product(BaseModel):\n    name = models.CharField(max_length=255)\n    price = models.DecimalField(max_digits=10, decimal_places=2)\n    description = models.TextField(blank=True)\n</code></pre> <pre><code>from unchained import Unchained\nfrom .models import Product\n\napp = Unchained()\napp.crud(Product)\n</code></pre> <pre><code># List all products\nGET /api/products\n\n# Get a specific product\nGET /api/products/1\n\n# Create a new product\nPOST /api/products\n{\n  \"name\": \"New Product\",\n  \"price\": 99.99,\n  \"description\": \"A fantastic new product\"\n}\n</code></pre>"},{"location":"crud/customizing/#further-reading","title":"Further Reading","text":"<p>For more information on the underlying technologies:</p> <ul> <li> Django Ninja documentation</li> <li> Django ORM documentation </li> </ul>"}]}